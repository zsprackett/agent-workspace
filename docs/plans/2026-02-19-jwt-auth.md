# JWT Auth with Refresh Tokens Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace HTTP Basic Auth with account-based JWT authentication using short-lived access tokens (1 hour) and long-lived refresh tokens (7 days, configurable) stored in SQLite.

**Architecture:** Accounts and refresh tokens live in new SQLite tables. A new `internal/webserver/auth.go` handles JWT issue/validate and middleware. CLI subcommands `adduser`/`passwd` manage accounts. The frontend stores the access token in memory and the refresh token in `localStorage`, silently refreshes on 401, and passes the token to SSE via query param.

**Tech Stack:** `github.com/golang-jwt/jwt/v5` for JWT signing/validation, `golang.org/x/crypto/bcrypt` (already in go.mod) for password hashing, vanilla JS frontend.

---

### Task 1: Add JWT library dependency

**Files:**
- Modify: `go.mod`, `go.sum`

**Step 1: Add the JWT library**

```bash
cd /Users/zsprackett/.agent-workspace/worktrees/github.com/zsprackett/agent-workspace/workspace
go get github.com/golang-jwt/jwt/v5
```

Expected: `go.mod` updated with `github.com/golang-jwt/jwt/v5`

**Step 2: Verify it builds**

```bash
go build ./...
```

Expected: no errors

**Step 3: Commit**

```bash
git add go.mod go.sum
git commit -m "chore: add golang-jwt/jwt dependency"
```

---

### Task 2: DB - accounts and refresh_tokens tables + CRUD

**Files:**
- Modify: `internal/db/db.go`
- Modify: `internal/db/types.go`
- Test: `internal/db/db_test.go`

**Step 1: Add types to `internal/db/types.go`**

Add after the existing type definitions:

```go
type Account struct {
	ID           string
	Username     string
	PasswordHash string
	CreatedAt    time.Time
}

type RefreshToken struct {
	Token     string
	AccountID string
	ExpiresAt time.Time
	CreatedAt time.Time
}
```

**Step 2: Write failing tests in `internal/db/db_test.go`**

Add to the test file:

```go
func TestAccountCRUD(t *testing.T) {
	store, _ := db.Open(":memory:")
	store.Migrate()
	defer store.Close()

	// CreateAccount
	acc, err := store.CreateAccount("alice", "hashed-pw")
	if err != nil {
		t.Fatalf("CreateAccount: %v", err)
	}
	if acc.Username != "alice" {
		t.Errorf("expected username alice, got %s", acc.Username)
	}
	if acc.ID == "" {
		t.Error("expected non-empty ID")
	}

	// GetAccountByUsername
	got, err := store.GetAccountByUsername("alice")
	if err != nil {
		t.Fatalf("GetAccountByUsername: %v", err)
	}
	if got.ID != acc.ID {
		t.Errorf("ID mismatch: %s != %s", got.ID, acc.ID)
	}

	// UpdateAccountPassword
	if err := store.UpdateAccountPassword(acc.ID, "new-hash"); err != nil {
		t.Fatalf("UpdateAccountPassword: %v", err)
	}
	got, _ = store.GetAccountByUsername("alice")
	if got.PasswordHash != "new-hash" {
		t.Error("password not updated")
	}

	// HasAnyAccount
	has, err := store.HasAnyAccount()
	if err != nil {
		t.Fatalf("HasAnyAccount: %v", err)
	}
	if !has {
		t.Error("expected HasAnyAccount to return true")
	}
}

func TestRefreshTokenCRUD(t *testing.T) {
	store, _ := db.Open(":memory:")
	store.Migrate()
	defer store.Close()

	acc, _ := store.CreateAccount("bob", "pw")
	exp := time.Now().Add(7 * 24 * time.Hour)

	// CreateRefreshToken
	if err := store.CreateRefreshToken("tok123", acc.ID, exp); err != nil {
		t.Fatalf("CreateRefreshToken: %v", err)
	}

	// GetRefreshToken - valid
	rt, err := store.GetRefreshToken("tok123")
	if err != nil {
		t.Fatalf("GetRefreshToken: %v", err)
	}
	if rt.AccountID != acc.ID {
		t.Errorf("AccountID mismatch")
	}

	// GetRefreshToken - missing
	_, err = store.GetRefreshToken("notexist")
	if err == nil {
		t.Error("expected error for missing token")
	}

	// DeleteRefreshToken
	if err := store.DeleteRefreshToken("tok123"); err != nil {
		t.Fatalf("DeleteRefreshToken: %v", err)
	}
	_, err = store.GetRefreshToken("tok123")
	if err == nil {
		t.Error("expected error after deletion")
	}

	// DeleteRefreshTokensByAccount
	store.CreateRefreshToken("tok-a1", acc.ID, exp)
	store.CreateRefreshToken("tok-a2", acc.ID, exp)
	if err := store.DeleteRefreshTokensByAccount(acc.ID); err != nil {
		t.Fatalf("DeleteRefreshTokensByAccount: %v", err)
	}
	_, err = store.GetRefreshToken("tok-a1")
	if err == nil {
		t.Error("expected tok-a1 deleted")
	}
}
```

**Step 3: Run tests to verify they fail**

```bash
go test ./internal/db/... -run TestAccountCRUD -v
go test ./internal/db/... -run TestRefreshTokenCRUD -v
```

Expected: FAIL with "store.CreateAccount undefined" or similar

**Step 4: Add migrations in `internal/db/db.go`**

Add after the last `ALTER TABLE` block in `Migrate()`, before `return nil`:

```go
_, err = d.sql.Exec(`
    CREATE TABLE IF NOT EXISTS accounts (
        id            TEXT PRIMARY KEY,
        username      TEXT NOT NULL UNIQUE,
        password_hash TEXT NOT NULL,
        created_at    INTEGER NOT NULL
    )
`)
if err != nil {
    return fmt.Errorf("create accounts: %w", err)
}

_, err = d.sql.Exec(`
    CREATE TABLE IF NOT EXISTS refresh_tokens (
        token      TEXT PRIMARY KEY,
        account_id TEXT NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
    )
`)
if err != nil {
    return fmt.Errorf("create refresh_tokens: %w", err)
}
```

**Step 5: Add CRUD methods in `internal/db/db.go`**

Add these functions (requires `"github.com/google/uuid"` or use `crypto/rand` -- use `crypto/rand` to avoid new dep):

```go
import "crypto/rand"
import "encoding/hex"

func randomID() string {
    b := make([]byte, 16)
    rand.Read(b)
    return hex.EncodeToString(b)
}

func (d *DB) CreateAccount(username, passwordHash string) (*Account, error) {
    acc := &Account{
        ID:           randomID(),
        Username:     username,
        PasswordHash: passwordHash,
        CreatedAt:    time.Now(),
    }
    _, err := d.sql.Exec(
        `INSERT INTO accounts (id, username, password_hash, created_at) VALUES (?,?,?,?)`,
        acc.ID, acc.Username, acc.PasswordHash, acc.CreatedAt.UnixMilli(),
    )
    return acc, err
}

func (d *DB) GetAccountByUsername(username string) (*Account, error) {
    row := d.sql.QueryRow(
        `SELECT id, username, password_hash, created_at FROM accounts WHERE username = ?`, username)
    var acc Account
    var createdAt int64
    if err := row.Scan(&acc.ID, &acc.Username, &acc.PasswordHash, &createdAt); err != nil {
        return nil, err
    }
    acc.CreatedAt = time.UnixMilli(createdAt)
    return &acc, nil
}

func (d *DB) UpdateAccountPassword(id, passwordHash string) error {
    _, err := d.sql.Exec(`UPDATE accounts SET password_hash = ? WHERE id = ?`, passwordHash, id)
    return err
}

func (d *DB) HasAnyAccount() (bool, error) {
    var count int
    err := d.sql.QueryRow(`SELECT COUNT(*) FROM accounts`).Scan(&count)
    return count > 0, err
}

func (d *DB) CreateRefreshToken(token, accountID string, expiresAt time.Time) error {
    _, err := d.sql.Exec(
        `INSERT INTO refresh_tokens (token, account_id, expires_at, created_at) VALUES (?,?,?,?)`,
        token, accountID, expiresAt.UnixMilli(), time.Now().UnixMilli(),
    )
    return err
}

func (d *DB) GetRefreshToken(token string) (*RefreshToken, error) {
    row := d.sql.QueryRow(
        `SELECT token, account_id, expires_at, created_at FROM refresh_tokens WHERE token = ?`, token)
    var rt RefreshToken
    var expiresAt, createdAt int64
    if err := row.Scan(&rt.Token, &rt.AccountID, &expiresAt, &createdAt); err != nil {
        return nil, err
    }
    rt.ExpiresAt = time.UnixMilli(expiresAt)
    rt.CreatedAt = time.UnixMilli(createdAt)
    return &rt, nil
}

func (d *DB) DeleteRefreshToken(token string) error {
    _, err := d.sql.Exec(`DELETE FROM refresh_tokens WHERE token = ?`, token)
    return err
}

func (d *DB) DeleteRefreshTokensByAccount(accountID string) error {
    _, err := d.sql.Exec(`DELETE FROM refresh_tokens WHERE account_id = ?`, accountID)
    return err
}
```

**Step 6: Run tests to verify they pass**

```bash
go test ./internal/db/... -run TestAccountCRUD -v
go test ./internal/db/... -run TestRefreshTokenCRUD -v
```

Expected: PASS

**Step 7: Run all DB tests**

```bash
go test ./internal/db/...
```

Expected: all PASS

**Step 8: Commit**

```bash
git add internal/db/db.go internal/db/types.go internal/db/db_test.go
git commit -m "feat: add accounts and refresh_tokens tables with CRUD"
```

---

### Task 3: Config - JWT secret and token TTL

**Files:**
- Modify: `internal/config/config.go`
- Modify: `internal/ui/app.go`

**Step 1: Update `AuthConfig` in `internal/config/config.go`**

Replace:

```go
type AuthConfig struct {
	Username string `json:"username"`
	Password string `json:"password"`
}
```

With:

```go
type AuthConfig struct {
	JWTSecret        string `json:"jwtSecret"`
	RefreshTokenTTL  string `json:"refreshTokenTTL"` // e.g. "168h", defaults to 7 days
}
```

**Step 2: Add `JWTSecret` auto-generation helper in `internal/config/config.go`**

```go
import "crypto/rand"
import "encoding/hex"

// EnsureJWTSecret generates and saves a JWT secret if one is not already set.
// It writes the updated config back to path.
func EnsureJWTSecret(path string, cfg *Config) error {
    if cfg.Webserver.Auth.JWTSecret != "" {
        return nil
    }
    b := make([]byte, 32)
    if _, err := rand.Read(b); err != nil {
        return err
    }
    cfg.Webserver.Auth.JWTSecret = hex.EncodeToString(b)
    data, err := json.MarshalIndent(cfg, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(path, data, 0600)
}
```

**Step 3: Update `internal/ui/app.go` - remove old auth fields**

In `NewApp`, the `webserver.Config` init passes `Auth`. Change:

```go
Auth: webserver.AuthConfig{
    Username: cfg.Webserver.Auth.Username,
    Password: cfg.Webserver.Auth.Password,
},
```

To:

```go
Auth: webserver.AuthConfig{
    JWTSecret:       cfg.Webserver.Auth.JWTSecret,
    RefreshTokenTTL: cfg.Webserver.Auth.RefreshTokenTTL,
},
```

**Step 4: Update `webserver.AuthConfig` struct** (in `internal/webserver/webserver.go`):

Replace:

```go
type AuthConfig struct {
	Username string
	Password string
}
```

With:

```go
type AuthConfig struct {
	JWTSecret       string
	RefreshTokenTTL string // parsed duration, e.g. "168h"
}
```

**Step 5: Build to verify**

```bash
go build ./...
```

Expected: no errors (old basicAuthMiddleware code will have compile errors -- fix them: remove the `if s.cfg.Auth.Username != ""` block in `Start()` for now, leaving just `handler := s.Handler()`)

**Step 6: Commit**

```bash
git add internal/config/config.go internal/ui/app.go internal/webserver/webserver.go
git commit -m "feat: replace basic auth config with JWT secret and token TTL"
```

---

### Task 4: Auth helpers in `internal/webserver/auth.go`

**Files:**
- Create: `internal/webserver/auth.go`
- Test: `internal/webserver/auth_test.go`

**Step 1: Write failing tests in `internal/webserver/auth_test.go`**

```go
package webserver_test

import (
	"testing"
	"time"

	"github.com/zsprackett/agent-workspace/internal/webserver"
)

func TestIssueAndValidateAccessToken(t *testing.T) {
	secret := "test-secret"
	token, err := webserver.IssueAccessToken(secret, "alice", time.Hour)
	if err != nil {
		t.Fatalf("IssueAccessToken: %v", err)
	}
	if token == "" {
		t.Fatal("expected non-empty token")
	}

	username, err := webserver.ValidateAccessToken(secret, token)
	if err != nil {
		t.Fatalf("ValidateAccessToken: %v", err)
	}
	if username != "alice" {
		t.Errorf("expected alice, got %s", username)
	}
}

func TestValidateAccessToken_Expired(t *testing.T) {
	secret := "test-secret"
	token, _ := webserver.IssueAccessToken(secret, "alice", -time.Second)
	_, err := webserver.ValidateAccessToken(secret, token)
	if err == nil {
		t.Error("expected error for expired token")
	}
}

func TestValidateAccessToken_WrongSecret(t *testing.T) {
	token, _ := webserver.IssueAccessToken("secret-a", "alice", time.Hour)
	_, err := webserver.ValidateAccessToken("secret-b", token)
	if err == nil {
		t.Error("expected error for wrong secret")
	}
}

func TestGenerateRefreshToken(t *testing.T) {
	tok1, err := webserver.GenerateRefreshToken()
	if err != nil {
		t.Fatalf("GenerateRefreshToken: %v", err)
	}
	tok2, _ := webserver.GenerateRefreshToken()
	if tok1 == tok2 {
		t.Error("expected unique tokens")
	}
	if len(tok1) != 64 { // 32 bytes hex = 64 chars
		t.Errorf("expected 64 char token, got %d", len(tok1))
	}
}
```

**Step 2: Run tests to verify they fail**

```bash
go test ./internal/webserver/... -run TestIssueAndValidateAccessToken -v
```

Expected: FAIL with "webserver.IssueAccessToken undefined"

**Step 3: Create `internal/webserver/auth.go`**

```go
package webserver

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// IssueAccessToken creates a signed HS256 JWT for the given username.
func IssueAccessToken(secret, username string, ttl time.Duration) (string, error) {
	claims := jwt.RegisteredClaims{
		Subject:   username,
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),
		IssuedAt:  jwt.NewNumericDate(time.Now()),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

// ValidateAccessToken parses and validates a JWT, returning the subject (username).
func ValidateAccessToken(secret, tokenStr string) (string, error) {
	token, err := jwt.ParseWithClaims(tokenStr, &jwt.RegisteredClaims{}, func(t *jwt.Token) (any, error) {
		if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
		}
		return []byte(secret), nil
	})
	if err != nil {
		return "", err
	}
	claims, ok := token.Claims.(*jwt.RegisteredClaims)
	if !ok || !token.Valid {
		return "", errors.New("invalid token")
	}
	return claims.Subject, nil
}

// GenerateRefreshToken returns a cryptographically random 32-byte hex string.
func GenerateRefreshToken() (string, error) {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

// contextKey is used to store the authenticated username in request context.
type contextKey string

const usernameKey contextKey = "username"

// jwtMiddleware validates the Bearer token in the Authorization header.
// Requests to public paths bypass validation.
// SSE connections may pass the token as ?token= query param.
func jwtMiddleware(secret string, publicPaths []string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		for _, p := range publicPaths {
			if r.URL.Path == p || strings.HasPrefix(r.URL.Path, p) {
				next.ServeHTTP(w, r)
				return
			}
		}

		tokenStr := ""
		if auth := r.Header.Get("Authorization"); strings.HasPrefix(auth, "Bearer ") {
			tokenStr = strings.TrimPrefix(auth, "Bearer ")
		} else if q := r.URL.Query().Get("token"); q != "" {
			tokenStr = q
		}

		if tokenStr == "" {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}

		username, err := ValidateAccessToken(secret, tokenStr)
		if err != nil {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}

		ctx := context.WithValue(r.Context(), usernameKey, username)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
```

Add `"context"` to imports.

**Step 4: Run tests to verify they pass**

```bash
go test ./internal/webserver/... -run TestIssueAndValidateAccessToken -v
go test ./internal/webserver/... -run TestValidateAccessToken_Expired -v
go test ./internal/webserver/... -run TestValidateAccessToken_WrongSecret -v
go test ./internal/webserver/... -run TestGenerateRefreshToken -v
```

Expected: all PASS

**Step 5: Commit**

```bash
git add internal/webserver/auth.go internal/webserver/auth_test.go
git commit -m "feat: add JWT issue/validate helpers and refresh token generator"
```

---

### Task 5: Login, refresh, and logout endpoints

**Files:**
- Modify: `internal/webserver/webserver.go`
- Test: `internal/webserver/webserver_test.go`

**Step 1: Write failing tests**

Add to `internal/webserver/webserver_test.go`:

```go
func newAuthServer(t *testing.T) (*webserver.Server, *db.DB) {
	t.Helper()
	store, _ := db.Open(":memory:")
	store.Migrate()
	t.Cleanup(func() { store.Close() })
	mgr := session.NewManager(store)
	srv := webserver.New(store, mgr, webserver.Config{
		Port:    0,
		Host:    "127.0.0.1",
		Enabled: true,
		Auth: webserver.AuthConfig{
			JWTSecret:       "test-secret",
			RefreshTokenTTL: "168h",
		},
	})
	// seed an account
	hash, _ := bcrypt.GenerateFromPassword([]byte("password"), bcrypt.DefaultCost)
	store.CreateAccount("alice", string(hash))
	return srv, store
}

func TestLoginEndpoint(t *testing.T) {
	srv, _ := newAuthServer(t)
	body := `{"username":"alice","password":"password"}`
	req := httptest.NewRequest("POST", "/api/auth/login", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)

	if w.Code != 200 {
		t.Fatalf("expected 200, got %d: %s", w.Code, w.Body.String())
	}
	var resp map[string]string
	json.NewDecoder(w.Body).Decode(&resp)
	if resp["access_token"] == "" {
		t.Error("expected access_token in response")
	}
	if resp["refresh_token"] == "" {
		t.Error("expected refresh_token in response")
	}
}

func TestLoginEndpoint_WrongPassword(t *testing.T) {
	srv, _ := newAuthServer(t)
	body := `{"username":"alice","password":"wrong"}`
	req := httptest.NewRequest("POST", "/api/auth/login", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 401 {
		t.Fatalf("expected 401, got %d", w.Code)
	}
}

func TestRefreshEndpoint(t *testing.T) {
	srv, store := newAuthServer(t)

	// Login first to get refresh token
	loginBody := `{"username":"alice","password":"password"}`
	loginReq := httptest.NewRequest("POST", "/api/auth/login", strings.NewReader(loginBody))
	loginReq.Header.Set("Content-Type", "application/json")
	loginW := httptest.NewRecorder()
	srv.Handler().ServeHTTP(loginW, loginReq)
	var loginResp map[string]string
	json.NewDecoder(loginW.Body).Decode(&loginResp)

	_ = store // store available if needed
	body := fmt.Sprintf(`{"refresh_token":"%s"}`, loginResp["refresh_token"])
	req := httptest.NewRequest("POST", "/api/auth/refresh", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 200 {
		t.Fatalf("expected 200, got %d: %s", w.Code, w.Body.String())
	}
	var resp map[string]string
	json.NewDecoder(w.Body).Decode(&resp)
	if resp["access_token"] == "" {
		t.Error("expected new access_token")
	}
	// Old refresh token should be gone (rotation)
	_, err := store.GetRefreshToken(loginResp["refresh_token"])
	if err == nil {
		t.Error("old refresh token should be deleted after rotation")
	}
}

func TestLogoutEndpoint(t *testing.T) {
	srv, store := newAuthServer(t)
	loginBody := `{"username":"alice","password":"password"}`
	loginReq := httptest.NewRequest("POST", "/api/auth/login", strings.NewReader(loginBody))
	loginReq.Header.Set("Content-Type", "application/json")
	loginW := httptest.NewRecorder()
	srv.Handler().ServeHTTP(loginW, loginReq)
	var loginResp map[string]string
	json.NewDecoder(loginW.Body).Decode(&loginResp)

	body := fmt.Sprintf(`{"refresh_token":"%s"}`, loginResp["refresh_token"])
	req := httptest.NewRequest("POST", "/api/auth/logout", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 204 {
		t.Fatalf("expected 204, got %d", w.Code)
	}
	_, err := store.GetRefreshToken(loginResp["refresh_token"])
	if err == nil {
		t.Error("refresh token should be deleted after logout")
	}
}
```

Add imports: `"strings"`, `"golang.org/x/crypto/bcrypt"`

**Step 2: Run tests to verify they fail**

```bash
go test ./internal/webserver/... -run TestLoginEndpoint -v
```

Expected: FAIL

**Step 3: Add handlers to `internal/webserver/webserver.go`**

Add to `Handler()`:

```go
mux.HandleFunc("POST /api/auth/login", s.handleLogin)
mux.HandleFunc("POST /api/auth/refresh", s.handleRefresh)
mux.HandleFunc("POST /api/auth/logout", s.handleLogout)
```

Add handler methods:

```go
func (s *Server) handleLogin(w http.ResponseWriter, r *http.Request) {
	var body struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		http.Error(w, "bad request", 400)
		return
	}
	acc, err := s.store.GetAccountByUsername(body.Username)
	if err != nil || bcrypt.CompareHashAndPassword([]byte(acc.PasswordHash), []byte(body.Password)) != nil {
		http.Error(w, "unauthorized", 401)
		return
	}
	ttl, err := time.ParseDuration(s.cfg.Auth.RefreshTokenTTL)
	if err != nil || ttl == 0 {
		ttl = 7 * 24 * time.Hour
	}
	accessToken, err := IssueAccessToken(s.cfg.Auth.JWTSecret, acc.Username, time.Hour)
	if err != nil {
		http.Error(w, "internal error", 500)
		return
	}
	refreshToken, err := GenerateRefreshToken()
	if err != nil {
		http.Error(w, "internal error", 500)
		return
	}
	if err := s.store.CreateRefreshToken(refreshToken, acc.ID, time.Now().Add(ttl)); err != nil {
		http.Error(w, "internal error", 500)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"access_token":  accessToken,
		"refresh_token": refreshToken,
	})
}

func (s *Server) handleRefresh(w http.ResponseWriter, r *http.Request) {
	var body struct {
		RefreshToken string `json:"refresh_token"`
	}
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		http.Error(w, "bad request", 400)
		return
	}
	rt, err := s.store.GetRefreshToken(body.RefreshToken)
	if err != nil || time.Now().After(rt.ExpiresAt) {
		http.Error(w, "unauthorized", 401)
		return
	}
	acc, err := s.store.GetAccountByID(rt.AccountID)
	if err != nil {
		http.Error(w, "unauthorized", 401)
		return
	}
	// Rotate: delete old, issue new
	s.store.DeleteRefreshToken(body.RefreshToken)

	ttl, err := time.ParseDuration(s.cfg.Auth.RefreshTokenTTL)
	if err != nil || ttl == 0 {
		ttl = 7 * 24 * time.Hour
	}
	accessToken, _ := IssueAccessToken(s.cfg.Auth.JWTSecret, acc.Username, time.Hour)
	newRefreshToken, _ := GenerateRefreshToken()
	s.store.CreateRefreshToken(newRefreshToken, acc.ID, time.Now().Add(ttl))

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"access_token":  accessToken,
		"refresh_token": newRefreshToken,
	})
}

func (s *Server) handleLogout(w http.ResponseWriter, r *http.Request) {
	var body struct {
		RefreshToken string `json:"refresh_token"`
	}
	json.NewDecoder(r.Body).Decode(&body)
	s.store.DeleteRefreshToken(body.RefreshToken)
	w.WriteHeader(204)
}
```

Add `GetAccountByID` to `internal/db/db.go`:

```go
func (d *DB) GetAccountByID(id string) (*Account, error) {
	row := d.sql.QueryRow(
		`SELECT id, username, password_hash, created_at FROM accounts WHERE id = ?`, id)
	var acc Account
	var createdAt int64
	if err := row.Scan(&acc.ID, &acc.Username, &acc.PasswordHash, &createdAt); err != nil {
		return nil, err
	}
	acc.CreatedAt = time.UnixMilli(createdAt)
	return &acc, nil
}
```

Add `"golang.org/x/crypto/bcrypt"` to imports in `webserver.go`.

**Step 4: Run tests to verify they pass**

```bash
go test ./internal/webserver/... -run "TestLoginEndpoint|TestRefreshEndpoint|TestLogoutEndpoint" -v
```

Expected: all PASS

**Step 5: Commit**

```bash
git add internal/webserver/webserver.go internal/webserver/webserver_test.go internal/db/db.go
git commit -m "feat: add login, refresh, and logout endpoints"
```

---

### Task 6: Apply JWT middleware to protect API routes

**Files:**
- Modify: `internal/webserver/webserver.go`
- Test: `internal/webserver/webserver_test.go`

**Step 1: Write failing test**

Add to `internal/webserver/webserver_test.go`:

```go
func TestProtectedEndpointRequiresAuth(t *testing.T) {
	srv, _ := newAuthServer(t)
	req := httptest.NewRequest("GET", "/api/sessions", nil)
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 401 {
		t.Fatalf("expected 401 without auth, got %d", w.Code)
	}
}

func TestProtectedEndpointWithValidToken(t *testing.T) {
	srv, _ := newAuthServer(t)
	token, _ := webserver.IssueAccessToken("test-secret", "alice", time.Hour)
	req := httptest.NewRequest("GET", "/api/sessions", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 200 {
		t.Fatalf("expected 200 with valid token, got %d", w.Code)
	}
}

func TestCertEndpointRemainsPublic(t *testing.T) {
	srv, _ := newAuthServer(t)
	req := httptest.NewRequest("GET", "/cert", nil)
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	// 404 is fine (no self-signed TLS configured) -- just not 401
	if w.Code == 401 {
		t.Fatal("expected /cert to be public, got 401")
	}
}
```

**Step 2: Run tests to verify they fail**

```bash
go test ./internal/webserver/... -run TestProtectedEndpoint -v
```

Expected: `TestProtectedEndpointRequiresAuth` FAIL (currently returns 200)

**Step 3: Apply middleware in `Handler()`**

Wrap the mux with `jwtMiddleware` when a JWT secret is configured. Update `Handler()`:

```go
func (s *Server) Handler() http.Handler {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /cert", s.handleCert)
	mux.HandleFunc("POST /api/auth/login", s.handleLogin)
	mux.HandleFunc("POST /api/auth/refresh", s.handleRefresh)
	mux.HandleFunc("POST /api/auth/logout", s.handleLogout)
	mux.HandleFunc("GET /api/sessions", s.handleSessions)
	mux.HandleFunc("POST /api/sessions", s.handleCreateSession)
	mux.HandleFunc("POST /api/sessions/{id}/notes", s.handleUpdateNotes)
	mux.HandleFunc("POST /api/sessions/{id}/stop", s.handleStopSession)
	mux.HandleFunc("POST /api/sessions/{id}/restart", s.handleRestartSession)
	mux.HandleFunc("DELETE /api/sessions/{id}", s.handleDeleteSession)
	mux.HandleFunc("GET /api/sessions/{id}/events", s.handleSessionEvents)
	mux.HandleFunc("DELETE /api/sessions/{id}/ttyd", s.handleKillTTYD)
	mux.HandleFunc("GET /terminal/{id}/", s.handleTerminalProxy)
	mux.HandleFunc("GET /events", s.handleSSE)
	mux.Handle("GET /", http.FileServer(staticFiles()))

	if s.cfg.Auth.JWTSecret == "" {
		return mux
	}
	publicPaths := []string{"/cert", "/api/auth/", "/login"}
	return jwtMiddleware(s.cfg.Auth.JWTSecret, publicPaths, mux)
}
```

Also remove the old basic auth block from `Start()` (it was already removed in Task 3).

**Step 4: Run tests to verify they pass**

```bash
go test ./internal/webserver/... -run "TestProtectedEndpoint|TestCertEndpointRemainsPublic" -v
```

Expected: all PASS

**Step 5: Run all webserver tests**

```bash
go test ./internal/webserver/...
```

Expected: all PASS (existing tests use `Config{Auth: AuthConfig{}}` so no secret = no auth, still works)

**Step 6: Commit**

```bash
git add internal/webserver/webserver.go internal/webserver/webserver_test.go
git commit -m "feat: apply JWT middleware to protect API routes"
```

---

### Task 7: CLI adduser and passwd subcommands

**Files:**
- Modify: `main.go`

**Step 1: Add subcommands to `main.go`**

Add before the `if !tmux.IsAvailable()` check:

```go
if len(os.Args) >= 3 && os.Args[1] == "adduser" {
    username := os.Args[2]
    fmt.Printf("Password for %s: ", username)
    pw, err := term.ReadPassword(int(os.Stdin.Fd()))
    fmt.Println()
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    hash, err := bcrypt.GenerateFromPassword(pw, bcrypt.DefaultCost)
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    store, err := openDB()
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    defer store.Close()
    if _, err := store.CreateAccount(username, string(hash)); err != nil {
        fmt.Fprintf(os.Stderr, "error creating account: %v\n", err)
        os.Exit(1)
    }
    fmt.Printf("Account created: %s\n", username)
    return
}

if len(os.Args) >= 3 && os.Args[1] == "passwd" {
    username := os.Args[2]
    fmt.Printf("New password for %s: ", username)
    pw, err := term.ReadPassword(int(os.Stdin.Fd()))
    fmt.Println()
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    hash, err := bcrypt.GenerateFromPassword(pw, bcrypt.DefaultCost)
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    store, err := openDB()
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
    defer store.Close()
    acc, err := store.GetAccountByUsername(username)
    if err != nil {
        fmt.Fprintf(os.Stderr, "error: user not found: %v\n", err)
        os.Exit(1)
    }
    store.UpdateAccountPassword(acc.ID, string(hash))
    store.DeleteRefreshTokensByAccount(acc.ID)
    fmt.Printf("Password updated: %s (all sessions invalidated)\n", username)
    return
}
```

Extract a shared `openDB()` helper to avoid duplication with the main path:

```go
func openDB() (*db.DB, error) {
    dbPath := config.DBPath()
    if err := os.MkdirAll(filepath.Dir(dbPath), 0700); err != nil {
        return nil, err
    }
    store, err := db.Open(dbPath)
    if err != nil {
        return nil, err
    }
    if err := store.Migrate(); err != nil {
        store.Close()
        return nil, err
    }
    return store, nil
}
```

Add imports: `"golang.org/x/crypto/bcrypt"`, `"golang.org/x/term"`

**Step 2: Build and manually test**

```bash
go build -o agent-workspace .
echo "" | ./agent-workspace adduser testuser
```

Expected: prompts for password, creates account

**Step 3: Call `config.EnsureJWTSecret` in main before starting the app**

In `main()`, after loading config and before `ui.NewApp`, add:

```go
if err := config.EnsureJWTSecret(config.DefaultPath(), &cfg); err != nil {
    fmt.Fprintf(os.Stderr, "warning: could not persist JWT secret: %v\n", err)
}
```

**Step 4: Build to verify**

```bash
go build ./...
```

Expected: no errors

**Step 5: Commit**

```bash
git add main.go internal/config/config.go
git commit -m "feat: add adduser and passwd CLI subcommands"
```

---

### Task 8: Login page frontend

**Files:**
- Create: `internal/webserver/static/login.html`

**Step 1: Create `internal/webserver/static/login.html`**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#0d1117">
  <title>agent-workspace â€“ login</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    .login-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 80dvh;
    }
    .login-box {
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 32px;
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .login-box h2 { font-size: 1rem; color: var(--text); }
    .login-box input {
      width: 100%;
      padding: 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }
    .login-box button {
      padding: 8px;
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
    }
    .login-box button:hover { border-color: var(--text); }
    .error { color: var(--error); font-size: 13px; min-height: 1em; }
  </style>
</head>
<body>
  <header>
    <h1>agent-workspace</h1>
  </header>
  <main class="login-wrap">
    <div class="login-box">
      <h2>Sign in</h2>
      <input id="username" type="text" placeholder="Username" autocomplete="username">
      <input id="password" type="password" placeholder="Password" autocomplete="current-password">
      <button id="submit">Sign in</button>
      <div id="error" class="error"></div>
    </div>
  </main>
  <script>
    async function login() {
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value;
      const errEl = document.getElementById('error');
      errEl.textContent = '';
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });
      if (!res.ok) {
        errEl.textContent = res.status === 401 ? 'Invalid username or password.' : 'Login failed.';
        return;
      }
      const { access_token, refresh_token } = await res.json();
      sessionStorage.setItem('access_token', access_token);
      localStorage.setItem('refresh_token', refresh_token);
      window.location.href = '/';
    }

    document.getElementById('submit').onclick = login;
    document.getElementById('password').addEventListener('keydown', e => {
      if (e.key === 'Enter') login();
    });
  </script>
</body>
</html>
```

Note: access token uses `sessionStorage` (cleared on tab close), refresh token uses `localStorage` (persists).

**Step 2: Add a `/login` route to serve it**

In `Handler()` in `webserver.go`, add before the file server catch-all:

```go
mux.HandleFunc("GET /login", func(w http.ResponseWriter, r *http.Request) {
    http.ServeFileFS(w, r, staticFS, "static/login.html")
})
```

**Step 3: Build to verify static file is embedded**

```bash
go build ./...
```

Expected: no errors

**Step 4: Commit**

```bash
git add internal/webserver/static/login.html internal/webserver/webserver.go
git commit -m "feat: add login page and /login route"
```

---

### Task 9: Update frontend to use JWT tokens

**Files:**
- Modify: `internal/webserver/static/app.js`
- Modify: `internal/webserver/static/index.html`

**Step 1: Add auth utilities and redirect logic at the top of `app.js`**

Add before `const STATUS_ICONS`:

```js
// --- Auth ---
function getAccessToken() { return sessionStorage.getItem('access_token'); }
function getRefreshToken() { return localStorage.getItem('refresh_token'); }
function setTokens(access, refresh) {
  sessionStorage.setItem('access_token', access);
  localStorage.setItem('refresh_token', refresh);
}
function clearTokens() {
  sessionStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
}

async function refreshAccessToken() {
  const rt = getRefreshToken();
  if (!rt) return false;
  const res = await fetch('/api/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refresh_token: rt }),
  });
  if (!res.ok) { clearTokens(); return false; }
  const { access_token, refresh_token } = await res.json();
  setTokens(access_token, refresh_token);
  return true;
}

async function authFetch(url, options = {}) {
  const token = getAccessToken();
  if (!token) { window.location.href = '/login'; return null; }
  options.headers = { ...options.headers, 'Authorization': 'Bearer ' + token };
  let res = await fetch(url, options);
  if (res.status === 401) {
    const ok = await refreshAccessToken();
    if (!ok) { window.location.href = '/login'; return null; }
    options.headers['Authorization'] = 'Bearer ' + getAccessToken();
    res = await fetch(url, options);
  }
  return res;
}

async function logout() {
  const rt = getRefreshToken();
  if (rt) {
    await fetch('/api/auth/logout', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refresh_token: rt }),
    });
  }
  clearTokens();
  window.location.href = '/login';
}
```

**Step 2: Replace `fetch` calls with `authFetch`**

- `fetchSessions`: replace `fetch('/api/sessions')` with `authFetch('/api/sessions')`; add null check `if (!res) return;`
- `loadEvents`: replace `fetch(...)` with `authFetch(...)`; add null check
- `saveNotes`: replace `fetch(...)` with `authFetch(...)`
- `apiAction`: replace `fetch(url, { method })` with `authFetch(url, { method })`
- In `render()`, the delete ttyd call: replace `fetch(...)` with `authFetch(...)`
- In `buildCreateForm`, the create session call: replace `fetch('/api/sessions', ...)` with `authFetch('/api/sessions', ...)`

**Step 3: Update `connectSSE` to use token query param**

Replace:
```js
const es = new EventSource('/events');
```
With:
```js
function connectSSE() {
  const token = getAccessToken();
  if (!token) { window.location.href = '/login'; return; }
  const es = new EventSource('/events?token=' + encodeURIComponent(token));
  // ... rest unchanged ...
  es.onerror = () => {
    dot.className = '';
    es.close();
    // On reconnect, check if token is still valid
    refreshAccessToken().then(ok => {
      if (!ok) { window.location.href = '/login'; return; }
      setTimeout(connectSSE, sseRetryDelay);
      sseRetryDelay = Math.min(sseRetryDelay * 2, 30000);
    });
  };
}
```

**Step 4: Add logout button to `index.html` header**

In `index.html`, replace:
```html
<div id="connection-status" title="SSE connection"></div>
```
With:
```html
<div style="display:flex;align-items:center;gap:12px">
  <div id="connection-status" title="SSE connection"></div>
  <button id="logout-btn" style="background:none;border:none;color:var(--muted);cursor:pointer;font-family:inherit;font-size:14px">logout</button>
</div>
```

In `app.js`, in the `DOMContentLoaded` handler add:
```js
document.getElementById('logout-btn').onclick = logout;
```

**Step 5: Add redirect check on page load**

In `DOMContentLoaded`, before `fetchSessions()` and `connectSSE()`, add:

```js
// If no token and not on login page, redirect
if (!getAccessToken() && !getRefreshToken()) {
  window.location.href = '/login';
  return;
}
// If we have a refresh token but no access token, refresh silently first
if (!getAccessToken() && getRefreshToken()) {
  const ok = await refreshAccessToken();
  if (!ok) { window.location.href = '/login'; return; }
}
```

Make the `DOMContentLoaded` callback `async`.

**Step 6: Build and verify**

```bash
go build ./...
```

**Step 7: Commit**

```bash
git add internal/webserver/static/app.js internal/webserver/static/index.html
git commit -m "feat: update frontend to use JWT auth with silent refresh"
```

---

### Task 10: Auth bypass when no accounts exist

**Files:**
- Modify: `internal/webserver/webserver.go`

**Step 1: Make auth conditional on accounts existing**

The middleware already skips auth when `JWTSecret == ""`. But we also want to skip it when no accounts exist in DB (for fresh installs before `adduser` is run).

Update `Handler()` to check:

```go
func (s *Server) Handler() http.Handler {
    mux := http.NewServeMux()
    // ... all routes ...

    if s.cfg.Auth.JWTSecret == "" {
        return mux
    }
    has, _ := s.store.HasAnyAccount()
    if !has {
        return mux
    }
    publicPaths := []string{"/cert", "/api/auth/", "/login"}
    return jwtMiddleware(s.cfg.Auth.JWTSecret, publicPaths, mux)
}
```

**Step 2: Write a test**

Add to `webserver_test.go`:

```go
func TestNoAuthWhenNoAccounts(t *testing.T) {
	store, _ := db.Open(":memory:")
	store.Migrate()
	defer store.Close()
	mgr := session.NewManager(store)
	// Auth configured but no accounts created
	srv := webserver.New(store, mgr, webserver.Config{
		Port: 0, Host: "127.0.0.1", Enabled: true,
		Auth: webserver.AuthConfig{JWTSecret: "secret", RefreshTokenTTL: "168h"},
	})
	req := httptest.NewRequest("GET", "/api/sessions", nil)
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)
	if w.Code != 200 {
		t.Fatalf("expected 200 with no accounts, got %d", w.Code)
	}
}
```

**Step 3: Run tests**

```bash
go test ./internal/webserver/...
```

Expected: all PASS

**Step 4: Build everything**

```bash
go build ./...
```

**Step 5: Commit**

```bash
git add internal/webserver/webserver.go internal/webserver/webserver_test.go
git commit -m "feat: skip auth middleware when no accounts exist"
```

---

### Task 11: Final wiring, install, and smoke test

**Files:**
- Modify: `main.go` (already updated in Task 7)

**Step 1: Run all tests**

```bash
go test ./...
```

Expected: all PASS

**Step 2: Install**

```bash
make install
```

**Step 3: Manual smoke test**

```bash
# Create an account
agent-workspace adduser admin
# Start the app, open browser
# Navigate to https://localhost:8443 -- should redirect to /login
# Log in with admin credentials -- should land on /
# Verify SSE connection dot goes green
# Verify logout button works
```

**Step 4: Push and PR**

```bash
git push
gh pr create --title "feat: replace basic auth with JWT + refresh tokens" --base main
```

---

## Notes

- The `randomID()` helper in `db.go` uses `crypto/rand` -- no new dependency
- `golang.org/x/term` is already in `go.mod` (used for `term.ReadPassword`)
- Auth is completely opt-in: if `JWTSecret` is empty or no accounts exist, all endpoints are public (backward compatible)
- The `jwtMiddleware` public paths use prefix matching for `/api/auth/` so all three auth endpoints are covered by one entry
